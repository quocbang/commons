// Code generated by protoc-gen-go. DO NOT EDIT.
// source: services.proto

package v2

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	api "gitlab.kenda.com.tw/kenda/commons/v2/proto/golang/mes/v2/api"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("services.proto", fileDescriptor_8e16ccb8c5307b32) }

var fileDescriptor_8e16ccb8c5307b32 = []byte{
	// 575 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0x4f, 0x6b, 0x13, 0x41,
	0x18, 0xc6, 0x59, 0x85, 0xaa, 0x43, 0x2b, 0x32, 0xb4, 0x96, 0x6e, 0xff, 0xa4, 0x19, 0x5b, 0x2b,
	0x95, 0xcc, 0x42, 0x7a, 0x91, 0xdc, 0xac, 0x28, 0x14, 0x84, 0x86, 0x80, 0x08, 0xde, 0x66, 0x77,
	0xdf, 0x2e, 0x43, 0x76, 0x67, 0xc6, 0x99, 0xd9, 0x94, 0x5e, 0x44, 0xc4, 0x8b, 0x27, 0x0f, 0x7e,
	0x02, 0x3f, 0x93, 0x5f, 0xc1, 0x0f, 0x22, 0x33, 0xbb, 0x2b, 0x69, 0xb2, 0x49, 0x7a, 0x5a, 0x36,
	0xcf, 0x93, 0xf7, 0xf7, 0x1b, 0x32, 0x79, 0xd1, 0x63, 0x03, 0x7a, 0xc2, 0x13, 0x30, 0x54, 0x69,
	0x69, 0x25, 0x5e, 0xf7, 0x0f, 0x5a, 0x80, 0xa1, 0x93, 0x7e, 0xb8, 0x97, 0x49, 0x99, 0xe5, 0x10,
	0x31, 0xc5, 0x23, 0x26, 0x84, 0xb4, 0xcc, 0x72, 0x29, 0xea, 0x6e, 0xb8, 0x5b, 0xa7, 0xfe, 0x2d,
	0x2e, 0xaf, 0x22, 0x28, 0x94, 0xbd, 0xa9, 0xc3, 0xd0, 0x3f, 0xa2, 0x02, 0x4c, 0x34, 0xe9, 0x57,
	0x03, 0x14, 0xaf, 0xb3, 0xee, 0x5c, 0xc6, 0x85, 0x51, 0x90, 0xb8, 0xe1, 0x55, 0xa5, 0xff, 0x03,
	0xa1, 0xfb, 0xaf, 0x87, 0x17, 0xd8, 0xa0, 0x47, 0x1f, 0xa5, 0x1e, 0x5f, 0xea, 0x14, 0x34, 0x26,
	0x74, 0xda, 0x8e, 0xba, 0x81, 0xff, 0xc3, 0x11, 0x7c, 0x2e, 0xc1, 0xd8, 0xf0, 0x70, 0x69, 0x47,
	0xe5, 0x37, 0xe4, 0xf0, 0xdb, 0x9f, 0xbf, 0xbf, 0xee, 0x85, 0x64, 0xcb, 0x0b, 0x38, 0xfa, 0xa4,
	0x1f, 0x5d, 0x4b, 0x3d, 0x96, 0xae, 0x33, 0x08, 0x4e, 0xf1, 0x18, 0x3d, 0xbc, 0x54, 0xa0, 0x99,
	0x95, 0x1a, 0x77, 0xe7, 0xe7, 0x35, 0x59, 0x83, 0xec, 0x2c, 0xab, 0x38, 0xe2, 0xae, 0x27, 0x6e,
	0x91, 0x27, 0xd3, 0x44, 0xc3, 0x33, 0xe1, 0x60, 0x5f, 0x03, 0xb4, 0x3e, 0x02, 0x23, 0x4b, 0x9d,
	0xc0, 0x39, 0x17, 0x29, 0x3e, 0x9e, 0x1f, 0x37, 0x9d, 0x37, 0xd4, 0x67, 0xab, 0x6a, 0x8e, 0x7c,
	0xe4, 0xc9, 0x07, 0x64, 0x67, 0x9a, 0xac, 0xeb, 0x5a, 0x14, 0x73, 0x91, 0xce, 0x2a, 0xbc, 0x03,
	0x58, 0xaa, 0xe0, 0xf2, 0x3b, 0x28, 0x54, 0xb5, 0xd5, 0x0a, 0x57, 0x00, 0x5e, 0xc1, 0xa2, 0x07,
	0x6f, 0x64, 0x9e, 0x43, 0x62, 0x71, 0xcb, 0x2f, 0x58, 0x47, 0x0d, 0xf7, 0x60, 0x49, 0xc3, 0x21,
	0x4f, 0x3c, 0xb2, 0x4b, 0xf6, 0x5a, 0x91, 0x49, 0x55, 0x75, 0xd4, 0xdf, 0x01, 0xda, 0x1c, 0x41,
	0x22, 0x75, 0x7a, 0x51, 0x5d, 0xc0, 0x11, 0x98, 0x32, 0xb7, 0x06, 0xf7, 0xda, 0x4e, 0x36, 0xdf,
	0x6b, 0x84, 0x5e, 0xde, 0xb5, 0xee, 0xec, 0x7a, 0xde, 0xee, 0x84, 0x90, 0xdb, 0x76, 0xae, 0xde,
	0xab, 0xff, 0x07, 0x3d, 0x5d, 0x7d, 0xc1, 0x39, 0x66, 0x68, 0x6d, 0x04, 0x09, 0x57, 0x80, 0x3b,
	0xad, 0x14, 0xae, 0xa0, 0xd1, 0xd8, 0x5f, 0x5c, 0x70, 0xe0, 0x7d, 0x0f, 0xde, 0x26, 0x78, 0x06,
	0xcc, 0x15, 0x38, 0xd0, 0xf7, 0x00, 0x6d, 0x54, 0xd6, 0x43, 0x96, 0x8c, 0xb9, 0xc8, 0xf0, 0xf3,
	0x45, 0xc7, 0xaa, 0x0b, 0x0d, 0xf7, 0x68, 0x65, 0xcf, 0xe1, 0x8f, 0x3d, 0xbe, 0x43, 0xc2, 0x96,
	0x73, 0xab, 0xaa, 0xe8, 0x34, 0xbe, 0xa0, 0x8d, 0xf7, 0xdc, 0xd8, 0xe6, 0x22, 0x99, 0x36, 0x8b,
	0x5b, 0x85, 0x25, 0x16, 0x33, 0x3d, 0x67, 0xd1, 0xf1, 0x16, 0x3b, 0x64, 0xb3, 0xed, 0x6e, 0x38,
	0xfe, 0xcf, 0x00, 0x85, 0x1f, 0x54, 0x2e, 0x59, 0x3a, 0xd4, 0x32, 0x2d, 0xfd, 0x52, 0x1a, 0x32,
	0xcd, 0x0a, 0xb0, 0xa0, 0x0d, 0x3e, 0x9b, 0xa7, 0x2c, 0x6e, 0x37, 0x6a, 0x4f, 0x69, 0xb5, 0x2a,
	0x69, 0xb3, 0x2a, 0xe9, 0x5b, 0xb7, 0x2a, 0x09, 0xf1, 0x32, 0x7b, 0x64, 0x7b, 0x5a, 0x26, 0xce,
	0x65, 0x1c, 0x95, 0x7e, 0xe6, 0x20, 0x38, 0x7d, 0x11, 0x9c, 0x0f, 0x3e, 0xbd, 0xca, 0xb8, 0xcd,
	0x59, 0x4c, 0xc7, 0x20, 0x52, 0x46, 0x13, 0x59, 0x50, 0x7b, 0x1d, 0xf9, 0x97, 0x28, 0x91, 0x45,
	0x21, 0x85, 0x5f, 0xa4, 0xd5, 0x56, 0xcd, 0x64, 0xce, 0x44, 0x56, 0x2f, 0xd7, 0x78, 0xcd, 0x7f,
	0x78, 0xf6, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xcb, 0xad, 0xab, 0xbc, 0xe8, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type APIClient interface {
	// 工單操作
	//
	// 工單操作包含以下功能:
	//  - 變更工單狀態(工單狀態請參考 ./workorder/workorder.proto enum Status),
	//    包含以下變更方式:
	//     - 跳過工單: 將 skipWorkOrders 內所有工單狀態變更為 SKIPPED. 將工單狀態從
	//                PENDING -> SKIPPED, 其他狀態不可執行此操作.
	//     - 投料結束工單: closeWorkOrder=指定結束工單, 工單狀態必須為 ACTIVE,
	//                    同時所有的首數(batch)狀態為 BATCH_PREPARING / BATCH_CLOSING / BATCH_CLOSED /
	//                    BATCH_CANCELLED (首數狀態請參考 ./workorder/workorder.proto enum BatchStatus)
	//                    任一種狀態, 系統將變更工單狀態為 CLOSING, 否則不可執行操作並將錯誤回饋到
	//                    WorkOrderReply.error.
	//                    系統一併會把全部首數狀態 = BATCH_PREPARING 更新成 BATCH_CANCELLED 代表該首數已被取消.
	//       您亦可透過指定 closeMode=ACTION_FORCE 進行強制執行, 程式同樣回饋錯誤警示並變更工單狀態.
	//       若工單狀態非上述允許的狀態, 則不可執行此操作, 即使指定 closeMode=ACTION_FORCE 也無法變更狀態.
	//     - 收料結束工單: finishWorkOrder=指定結束工單, 不檢查首數狀態.
	//     - 執行工單: 依據 startWorkOrder 執行指定工單. 將工單狀態從 PENDING -> ACTIVE, 其他狀態不可執行此操作.
	//  - 查詢工單資料: 依據 loadWorkOrders 查詢工單資料, 詳細操作請參考 ./workorder/workorder.proto
	//                message WorkOrderRequest.LoadWorkOrders. 其查詢結果為 workOrders.
	//     - 查詢工單(todosWithDetails): 表示取得工單需含該作業流程所需用到配方以及機台參數.
	//  - 變更首數狀態: 透過指定 batchAction 變更指定工單的首數狀態.
	//
	// 若一個請求包含上述所有功能, 系統執行順序為 [變更首數狀態] -> [變更工單狀態] -> [查詢工單資料].
	//
	// 取得TODO工單回傳資訊:
	//  - id: 工單號
	//  - process: 生產作業階段
	//  - batches.count: 目標生產總批次
	//  - batches size分三種類型表示(只會出現一種), 分別用來表示 batches.count 對應關係:
	//     - unitQuantity: 為 true 的話, 表示為單位數量, 如: 成型每次生產一條生胎
	//     - fixedQuantity: 每次批次產出數量為固定數值, 依研發單位制定
	//     - perBatchQuantities: 每次批次產出數量不同, 派工決定該批次產出數量
	//  - status: 工單狀態, 請參考 ./workorder/workorder.proto enum Status
	//  - fedBatch: 已經投入材料的批次
	//  - collectedBatch: 已收取成品的批次
	//  - recipe: details格式為[key]value的型式, 如下說明:
	//     - groupedResources : 材料
	//        - STEP-${n}-MATERIALS : 表示各階段所需使用的材料, ${n}為大於0整數
	//           - requirements : 材料清單
	//        - TOOLS : 表示作業所需使用的製工具清單
	//           - requirements : 工具清單
	//     - groupedParams : 機台參數
	//        - STEP-${n}-CONTROL : 表示各階段機台設定參數, ${n}為大於0整數
	//           - params : 參數清單
	//        - STEP-${n}-MEASUREMENT : 表示各階段機台量測參數, ${n}為大於0整數
	//           - params : 參數清單
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - Error_ERROR_BATCH_NOT_FOUND (找不到工單作業批次)
	//  - Error_ERROR_WORKORDER_BAD_BATCH (錯誤的作業批次)
	//  - Error_ERROR_WORKORDER_NOT_FOUND (找不到工單)
	//  - Error_ERROR_WORKORDER_BAD_STATUS (工單狀態錯誤不允許進行操作)
	WorkOrder(ctx context.Context, in *api.WorkOrderRequest, opts ...grpc.CallOption) (*api.WorkOrderReply, error)
	// 作業員登入出機台工位
	//
	// 指定 in 的值表示為登入或登出. 登入: in=true; 登出: in=false.
	// 欲登入出的作業員身分指定於 metadata 的 User-Id, 而登入出的機台工位則分別依據 metadata 的
	//  Station 和 Site.
	//
	// 登入時必需指定:
	//  - workDate: 工作日, unix nano格式.
	//  - group: 工作群組, 將影響生產批號(詳細請參考 rpc Collect).
	//
	// 登出時僅需指定: in=false.
	//
	// 如果 onlyValidation 指定為 true, 表示檢查該工號是否為在職.
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - Error_ERROR_USER_NOT_FOUND_OR_BAD_PASSWORD (使用者已離職或密碼錯誤)
	//  - Error_ERROR_US_MISMATCH (作業員與機台登入人員不符, 無法登出)
	//  - Error_ERROR_US_SIGN_ON_FORBIDDEN (上一位使用者沒登出, 無法登入)
	Operator(ctx context.Context, in *api.OperatorRequest, opts ...grpc.CallOption) (*api.OperatorReply, error)
	// 條碼掛載
	//
	// Check & Bind Material(目前不含工具掛載)
	// 材料檢查, 掛載包含以下操作模式(依據 check.actionMode 決定):
	//  - ACTION_AUTO: 材料檢查(參考下面材料檢查), 材料檢查成功後, 則進行材料綁定(參考下面材料掛載).
	//  - ACTION_FORCE: 材料檢查(參考下面材料檢查), 不論材料檢查結果, 皆進行材料綁定(參考下面材料掛載).
	//  - ACTION_PRECHECK: 僅材料檢查(參考下面材料檢查), 若有給工單號則會檢查材料是否足夠配方需求.
	//
	// 工單檢查:
	//  - 如有指定生產工單(check.workOrder), 檢查工單狀態是否可以進行綁定材料(Status_ACTIVE/Status_PENDING 狀態才能進行掛載).
	//  - 如有指定生產批次(check.batch), 檢查該作業批次是否可以進行綁定材料(BatchStatus_BATCH_PREPARING/BatchStatus_BATCH_STARTED 狀態才能進行掛載).
	//  - 指定工單會檢查配方表是否存在.
	//  - 未來binds.workOrder, binds.batch 會棄用, 統一從check取得相關資訊.
	//
	// 材料檢查:
	//  - 檢查指定條碼(binds.resource.ID)是否可以使用(庫存數,到期日,狀態等),
	//    如果是force mode下, 如果材料條碼不存在也會允許可以掛載, 但必須指定實際秤重量(binds.resource.quantity不得為空).
	//  - 有指定工單並取得配方表會檢查材料是否符合(各材料滿足配方所需數量).
	//
	// 材料掛載:
	//  - binds.type: 指定材料綁定的方式 參考 BindType enum.
	//  - 將 binds.resource 綁定至對應的 site,
	//    site unique/index/resource 未來會拿掉, 可統一先設置 unique=true.
	//  - 綁定指定數量(實際秤重): binds.quantityGrouped == true 來決定是否將材料進行群組(將料號一樣/可替代的材料統一秤重),
	//    如數量為0會檢查前面是否有相同料號的材料有指定數量, 則視為材料群組, 系統將計算各別綁定的數量.
	//    例如: 材料 a 能使用材料 b 替代, 請求中的 binds.resources 指定兩張條碼({resource.id = a, quantity = 40}
	//    和 {resource.id = b, quantity = 0})綁定於 LINE site, 在 a 材料庫存為10的情況, 系統可能將材料 a 綁定10,
	//    材料 b 綁定30.
	//    在未使用材料群組情況指定綁定數量為0時, 系統不會綁定材料並回傳相應錯誤, 若使用強制執行(ACTION_FORCE)
	//    進行操作, 系統會將數量為0的材料綁定至指定的 site.
	//
	// 材料卸載(如: pop, clear): binds.resources 可以為空.
	//
	// 回傳:
	//  - 有給條碼(binds.resource.ID)的情況, 必會回傳指定條碼對應的材料資訊(results.info).
	//  - 如材料有錯誤會紀錄在相對應results.ID底下, 其於沒有對應條碼的錯誤會是機台或者工單錯誤等.
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - ERROR_WORKORDER_NOT_FOUND (找不到指定的工單)
	//  - ERROR_WORKORDER_BAD_BATCH (該工單作業批次狀態無法進行掛載)
	//  - ERROR_BATCH_NOT_FOUND (找不到指定的作業批次)
	//  - ERROR_US_MISMATCH (操作人員與機台登入人員不符)
	//  - ERROR_SR_SITE_NOT_FOUND (找不到指定操作工位)
	//  - ERROR_SW_MISMATCH (操作機台與派工單不符)
	//  - ERROR_RW_RESOURCE_MISSING (部份所需的材料未齊全)
	//  - ERROR_RESOURCE_NOT_FOUND (材料條碼不存在)
	//  - ERROR_RESOURCE_EXPIRED (材料過期)
	//  - ERROR_RESOURCE_ON_HOLD (材料狀態不能使用)
	//  - ERROR_RW_QUANTITY_BELOW_MIN (材料用量低於最低限制用量)
	//  - ERROR_RW_QUANTITY_ABOVE_MAX (材料用量高於最高限制用量)
	//  - ERROR_RW_QUANTITY_SHORTAGE (材料庫存不足))
	//  - ERROR_RW_BAD_GRADE (材料等級不符)
	//  - ERROR_RW_RESOURCE_UNEXPECTED (材料與配方不符)
	ResourceBind(ctx context.Context, in *api.ResourceBindRequest, opts ...grpc.CallOption) (*api.ResourceBindReply, error)
	// 投料
	//
	// 投料功能須指定投料的工單(check.workOrder)
	//
	// 系統將依據 feeds 指定將從哪個材料工位(feeds.site) 或 投入指定某材料(feeds.resource)進行投料,
	// site.unique/index/resource 未來只會剩下index.
	// 投料必為依工位或投入指定材料條碼其中一個
	//
	// 材料檢查:
	//  - 檢查指定工位投入的材料是否可以使用,是否過期,庫存量等, 結果紀錄至 ResourceFeedReply.results.
	//
	// 生產紀錄:
	//  - 依據 feeds.quantity 數量進行生產紀錄, 如沒有給重量(feeds.quantity==null)則當作掛載的材料全部投入.
	//  - 一般執行(ACTION_AUTO)下重量給0時, 將不會紀錄生產資訊, 並回傳錯誤訊息.
	//  - 強制執行(ACTION_FORCE)下重量給0時, 強制投料, 並且紀錄數量為0的生產紀錄, 並回傳錯誤訊息.
	//
	// feeds.cumulative/byCollectInfo 功能未來將不支援.
	// closeBatch == true, 該次投料成功後, 該首數將不能再次投料(視為結束投料).
	// doNotStartBatch == true, 表示實際投料但並未開始生產, 系統會紀錄投料資訊但不變更首數狀態. (未來將棄用)
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - ERROR_RESOURCE_NOT_FOUND (材料條碼不存在)
	//  - ERROR_RESOURCE_EXPIRED (材料過期)
	//  - ERROR_RESOURCE_ON_HOLD (材料狀態不能使用)
	//  - ERROR_WORKORDER_NOT_FOUND (找不到指定的工單)
	//  - ERROR_WORKORDER_BAD_BATCH (該工單作業批次狀態無法進行掛載)
	//  - ERROR_BATCH_NOT_FOUND (找不到指定的作業批次)
	//  - ERROR_US_MISMATCH (操作人員與機台登入人員不符)
	//  - ERROR_SR_SITE_NOT_FOUND (找不到指定操作工位)
	//  - ERROR_SW_MISMATCH (操作機台與派工單不符)
	//  - ERROR_RW_QUANTITY_BELOW_MIN (材料用量低於配合表最低用量)
	//  - ERROR_RW_QUANTITY_ABOVE_MAX (材料用量高於配合表最高用量)
	//  - ERROR_RW_QUANTITY_SHORTAGE (材料庫存不足))
	//  - ERROR_RW_BAD_GRADE (材料等級不符)
	//  - ERROR_RW_RESOURCE_UNEXPECTED (材料與配方不符)
	//  - ERROR_RW_RESOURCE_MISSING (部份所需的材料未齊全)
	ResourceFeed(ctx context.Context, in *api.ResourceFeedRequest, opts ...grpc.CallOption) (*api.ResourceFeedReply, error)
	// 收料
	//
	// 收料功能將會進行收料以及產出紀錄. 您必須指定 workOrder, collectBatch, quantity 告訴系統欲收料的工單號碼, 收料量
	// 相當於幾個首數(預設為1), 收料量.
	// 部份工程不提供工單要可以進行收料, 則需指定 product 資訊(id, type, unit)
	// ps: 不提供工單進行投收料的工程不得指定 Feed.AccordingRecipe.
	//
	// 您可透過 resource 指定這批產出的製品/成品紀錄至指定的標示卡條碼, 若無指定, 系統將自動產生一組標示卡條碼, 可從
	// CollectReply.resource 得知其標示卡號碼. 當您未指定標示卡條碼時, 您必須透過 carrier 指定其標示卡條碼應放置於哪一
	// 載具.
	// 部份工程沒有使用載具或是沒有規劃相關流程, 但有指定收料條碼(resource.ID), 則 carrier 可以不傳.
	//
	// 系統依據 actionMode 分成兩種執行模式: 一般執行(ACTION_AUTO)和強制執行(ACTION_FORCE), 預設為一般執行. 當處理請求
	// 時遇到系統認定為不正常操作(例如: 該首數狀態不可收料, 收料量大於投料量等)時, 會回饋錯誤到 CollectReply.error.
	// 您亦可透過強制執行(actionMode=ACTION_FORCE), 系統仍回饋錯誤並執行收料及產出紀錄, 依情況恐怕發生資料不齊全或無法
	// 預期狀況, 例如標示卡不存在的話, 將導致後段工程仍舊無法使用該條碼, 即使收料請求已被系統接受並執行.
	//
	// 若您想知道該批製品/成品更進一步資訊, 可透過 labelFields 指定需要知道的資訊, 目前支援:
	//  - product_type: 製品/成品類別, 例如: 天然橡膠, 合成橡膠, 鋼絲圈...等.
	//  - process_name: 製品生產流程代號
	//  - collect_quantity: 收取數
	//  - station: 機台號碼
	//  - manufacture_date: 製造日期時間
	//  - expiry: 製品/成品過期日期時間
	//  - operator: 收料人員
	//  - batch: 工單號碼+collectBatch
	//  - lot: 標示卡號碼
	//  - lot_number: 生產批號, 格式: 1碼工作群組+2碼機台編號+"-"+2碼月份+2碼日期, 例如: 工作群組=5, 機台編號=3,
	//                日期=2021-02-03, 其生產批號為: 503-0203.
	// 以上資訊可從 CollectReply.labelFields 獲得.
	//
	// 若您僅需要查詢收料紀錄, 可指定 onlyQueryLabels=true, 並給予以下資訊:
	//  - 工單編號(workOrder)
	//  - 收料序號(sequence)
	//  - 查詢欄位(labelFields)
	// 系統亦依據 metadata 的操作機台和當前登入人員, 篩選對應的收料紀錄(依據工單編號+生產批號+收料序號).
	// 若存在收料記錄, 依據 labelFields 回傳資料; 若不存在則回傳錯誤.
	//
	// 包含投料功能:
	//  - Feed.feeds 參考 resourceFeed 指定投入材料 or 從 site 投入指定材料
	//  - Feed.AccordingRecipe 決定是否依照配合表重量扣重, 不指定的話 feeds 投入材料必填重量
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - ERROR_RESOURCE_NOT_FOUND (材料條碼不存在)
	//  - ERROR_RESOURCE_EXISTED (收料標示卡已存在)
	//  - ERROR_WORKORDER_NOT_FOUND (找不到指定的工單)
	//  - ERROR_WORKORDER_BAD_BATCH (該工單作業批次狀態無法進行掛載)
	//  - ERROR_CARRIER_NOT_FOUND (找不到指定收取容器條碼)
	//  - ERROR_CARRIER_IN_USE (收料容器已被使用)
	//  - ERROR_BATCH_NOT_READY (該作業批次還不能收料)
	//  - ERROR_RW_QUANTITY_ABOVE_MAX (收取數量大於投料量, 超出允許收料範圍)
	//  - ERROR_WORKORDER_BAD_STATUS (工單狀態錯誤不允許進行操作)
	//  - ERROR_RECORD_EXISTED (收料紀錄已經存在)
	//  - ERROR_RECORD_NOT_FOUND (找不到收料紀錄)
	Collect(ctx context.Context, in *api.CollectRequest, opts ...grpc.CallOption) (*api.CollectReply, error)
	// 寫入檢測數據
	RecordInspectResults(ctx context.Context, in *api.RecordInspectResultsRequest, opts ...grpc.CallOption) (*api.RecordInspectResultsReply, error)
	// 查詢基準
	Recipe(ctx context.Context, in *api.RecipeRequest, opts ...grpc.CallOption) (*api.RecipeReply, error)
	// 紀錄包裝秤重
	RecordPacking(ctx context.Context, in *api.RecordPackingRequest, opts ...grpc.CallOption) (*api.RecordPackingReply, error)
	// 條碼查詢
	ListResources(ctx context.Context, in *api.ListResourcesRequest, opts ...grpc.CallOption) (*api.ListResourcesReply, error)
	// 參數上傳
	UploadProductionParameters(ctx context.Context, opts ...grpc.CallOption) (API_UploadProductionParametersClient, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) WorkOrder(ctx context.Context, in *api.WorkOrderRequest, opts ...grpc.CallOption) (*api.WorkOrderReply, error) {
	out := new(api.WorkOrderReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/WorkOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Operator(ctx context.Context, in *api.OperatorRequest, opts ...grpc.CallOption) (*api.OperatorReply, error) {
	out := new(api.OperatorReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/Operator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ResourceBind(ctx context.Context, in *api.ResourceBindRequest, opts ...grpc.CallOption) (*api.ResourceBindReply, error) {
	out := new(api.ResourceBindReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/ResourceBind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ResourceFeed(ctx context.Context, in *api.ResourceFeedRequest, opts ...grpc.CallOption) (*api.ResourceFeedReply, error) {
	out := new(api.ResourceFeedReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/ResourceFeed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Collect(ctx context.Context, in *api.CollectRequest, opts ...grpc.CallOption) (*api.CollectReply, error) {
	out := new(api.CollectReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/Collect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RecordInspectResults(ctx context.Context, in *api.RecordInspectResultsRequest, opts ...grpc.CallOption) (*api.RecordInspectResultsReply, error) {
	out := new(api.RecordInspectResultsReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/RecordInspectResults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Recipe(ctx context.Context, in *api.RecipeRequest, opts ...grpc.CallOption) (*api.RecipeReply, error) {
	out := new(api.RecipeReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/Recipe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RecordPacking(ctx context.Context, in *api.RecordPackingRequest, opts ...grpc.CallOption) (*api.RecordPackingReply, error) {
	out := new(api.RecordPackingReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/RecordPacking", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListResources(ctx context.Context, in *api.ListResourcesRequest, opts ...grpc.CallOption) (*api.ListResourcesReply, error) {
	out := new(api.ListResourcesReply)
	err := c.cc.Invoke(ctx, "/proto.mes.v2.API/ListResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) UploadProductionParameters(ctx context.Context, opts ...grpc.CallOption) (API_UploadProductionParametersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[0], "/proto.mes.v2.API/UploadProductionParameters", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIUploadProductionParametersClient{stream}
	return x, nil
}

type API_UploadProductionParametersClient interface {
	Send(*api.UploadProductionParametersRequest) error
	CloseAndRecv() (*empty.Empty, error)
	grpc.ClientStream
}

type aPIUploadProductionParametersClient struct {
	grpc.ClientStream
}

func (x *aPIUploadProductionParametersClient) Send(m *api.UploadProductionParametersRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPIUploadProductionParametersClient) CloseAndRecv() (*empty.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// APIServer is the server API for API service.
type APIServer interface {
	// 工單操作
	//
	// 工單操作包含以下功能:
	//  - 變更工單狀態(工單狀態請參考 ./workorder/workorder.proto enum Status),
	//    包含以下變更方式:
	//     - 跳過工單: 將 skipWorkOrders 內所有工單狀態變更為 SKIPPED. 將工單狀態從
	//                PENDING -> SKIPPED, 其他狀態不可執行此操作.
	//     - 投料結束工單: closeWorkOrder=指定結束工單, 工單狀態必須為 ACTIVE,
	//                    同時所有的首數(batch)狀態為 BATCH_PREPARING / BATCH_CLOSING / BATCH_CLOSED /
	//                    BATCH_CANCELLED (首數狀態請參考 ./workorder/workorder.proto enum BatchStatus)
	//                    任一種狀態, 系統將變更工單狀態為 CLOSING, 否則不可執行操作並將錯誤回饋到
	//                    WorkOrderReply.error.
	//                    系統一併會把全部首數狀態 = BATCH_PREPARING 更新成 BATCH_CANCELLED 代表該首數已被取消.
	//       您亦可透過指定 closeMode=ACTION_FORCE 進行強制執行, 程式同樣回饋錯誤警示並變更工單狀態.
	//       若工單狀態非上述允許的狀態, 則不可執行此操作, 即使指定 closeMode=ACTION_FORCE 也無法變更狀態.
	//     - 收料結束工單: finishWorkOrder=指定結束工單, 不檢查首數狀態.
	//     - 執行工單: 依據 startWorkOrder 執行指定工單. 將工單狀態從 PENDING -> ACTIVE, 其他狀態不可執行此操作.
	//  - 查詢工單資料: 依據 loadWorkOrders 查詢工單資料, 詳細操作請參考 ./workorder/workorder.proto
	//                message WorkOrderRequest.LoadWorkOrders. 其查詢結果為 workOrders.
	//     - 查詢工單(todosWithDetails): 表示取得工單需含該作業流程所需用到配方以及機台參數.
	//  - 變更首數狀態: 透過指定 batchAction 變更指定工單的首數狀態.
	//
	// 若一個請求包含上述所有功能, 系統執行順序為 [變更首數狀態] -> [變更工單狀態] -> [查詢工單資料].
	//
	// 取得TODO工單回傳資訊:
	//  - id: 工單號
	//  - process: 生產作業階段
	//  - batches.count: 目標生產總批次
	//  - batches size分三種類型表示(只會出現一種), 分別用來表示 batches.count 對應關係:
	//     - unitQuantity: 為 true 的話, 表示為單位數量, 如: 成型每次生產一條生胎
	//     - fixedQuantity: 每次批次產出數量為固定數值, 依研發單位制定
	//     - perBatchQuantities: 每次批次產出數量不同, 派工決定該批次產出數量
	//  - status: 工單狀態, 請參考 ./workorder/workorder.proto enum Status
	//  - fedBatch: 已經投入材料的批次
	//  - collectedBatch: 已收取成品的批次
	//  - recipe: details格式為[key]value的型式, 如下說明:
	//     - groupedResources : 材料
	//        - STEP-${n}-MATERIALS : 表示各階段所需使用的材料, ${n}為大於0整數
	//           - requirements : 材料清單
	//        - TOOLS : 表示作業所需使用的製工具清單
	//           - requirements : 工具清單
	//     - groupedParams : 機台參數
	//        - STEP-${n}-CONTROL : 表示各階段機台設定參數, ${n}為大於0整數
	//           - params : 參數清單
	//        - STEP-${n}-MEASUREMENT : 表示各階段機台量測參數, ${n}為大於0整數
	//           - params : 參數清單
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - Error_ERROR_BATCH_NOT_FOUND (找不到工單作業批次)
	//  - Error_ERROR_WORKORDER_BAD_BATCH (錯誤的作業批次)
	//  - Error_ERROR_WORKORDER_NOT_FOUND (找不到工單)
	//  - Error_ERROR_WORKORDER_BAD_STATUS (工單狀態錯誤不允許進行操作)
	WorkOrder(context.Context, *api.WorkOrderRequest) (*api.WorkOrderReply, error)
	// 作業員登入出機台工位
	//
	// 指定 in 的值表示為登入或登出. 登入: in=true; 登出: in=false.
	// 欲登入出的作業員身分指定於 metadata 的 User-Id, 而登入出的機台工位則分別依據 metadata 的
	//  Station 和 Site.
	//
	// 登入時必需指定:
	//  - workDate: 工作日, unix nano格式.
	//  - group: 工作群組, 將影響生產批號(詳細請參考 rpc Collect).
	//
	// 登出時僅需指定: in=false.
	//
	// 如果 onlyValidation 指定為 true, 表示檢查該工號是否為在職.
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - Error_ERROR_USER_NOT_FOUND_OR_BAD_PASSWORD (使用者已離職或密碼錯誤)
	//  - Error_ERROR_US_MISMATCH (作業員與機台登入人員不符, 無法登出)
	//  - Error_ERROR_US_SIGN_ON_FORBIDDEN (上一位使用者沒登出, 無法登入)
	Operator(context.Context, *api.OperatorRequest) (*api.OperatorReply, error)
	// 條碼掛載
	//
	// Check & Bind Material(目前不含工具掛載)
	// 材料檢查, 掛載包含以下操作模式(依據 check.actionMode 決定):
	//  - ACTION_AUTO: 材料檢查(參考下面材料檢查), 材料檢查成功後, 則進行材料綁定(參考下面材料掛載).
	//  - ACTION_FORCE: 材料檢查(參考下面材料檢查), 不論材料檢查結果, 皆進行材料綁定(參考下面材料掛載).
	//  - ACTION_PRECHECK: 僅材料檢查(參考下面材料檢查), 若有給工單號則會檢查材料是否足夠配方需求.
	//
	// 工單檢查:
	//  - 如有指定生產工單(check.workOrder), 檢查工單狀態是否可以進行綁定材料(Status_ACTIVE/Status_PENDING 狀態才能進行掛載).
	//  - 如有指定生產批次(check.batch), 檢查該作業批次是否可以進行綁定材料(BatchStatus_BATCH_PREPARING/BatchStatus_BATCH_STARTED 狀態才能進行掛載).
	//  - 指定工單會檢查配方表是否存在.
	//  - 未來binds.workOrder, binds.batch 會棄用, 統一從check取得相關資訊.
	//
	// 材料檢查:
	//  - 檢查指定條碼(binds.resource.ID)是否可以使用(庫存數,到期日,狀態等),
	//    如果是force mode下, 如果材料條碼不存在也會允許可以掛載, 但必須指定實際秤重量(binds.resource.quantity不得為空).
	//  - 有指定工單並取得配方表會檢查材料是否符合(各材料滿足配方所需數量).
	//
	// 材料掛載:
	//  - binds.type: 指定材料綁定的方式 參考 BindType enum.
	//  - 將 binds.resource 綁定至對應的 site,
	//    site unique/index/resource 未來會拿掉, 可統一先設置 unique=true.
	//  - 綁定指定數量(實際秤重): binds.quantityGrouped == true 來決定是否將材料進行群組(將料號一樣/可替代的材料統一秤重),
	//    如數量為0會檢查前面是否有相同料號的材料有指定數量, 則視為材料群組, 系統將計算各別綁定的數量.
	//    例如: 材料 a 能使用材料 b 替代, 請求中的 binds.resources 指定兩張條碼({resource.id = a, quantity = 40}
	//    和 {resource.id = b, quantity = 0})綁定於 LINE site, 在 a 材料庫存為10的情況, 系統可能將材料 a 綁定10,
	//    材料 b 綁定30.
	//    在未使用材料群組情況指定綁定數量為0時, 系統不會綁定材料並回傳相應錯誤, 若使用強制執行(ACTION_FORCE)
	//    進行操作, 系統會將數量為0的材料綁定至指定的 site.
	//
	// 材料卸載(如: pop, clear): binds.resources 可以為空.
	//
	// 回傳:
	//  - 有給條碼(binds.resource.ID)的情況, 必會回傳指定條碼對應的材料資訊(results.info).
	//  - 如材料有錯誤會紀錄在相對應results.ID底下, 其於沒有對應條碼的錯誤會是機台或者工單錯誤等.
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - ERROR_WORKORDER_NOT_FOUND (找不到指定的工單)
	//  - ERROR_WORKORDER_BAD_BATCH (該工單作業批次狀態無法進行掛載)
	//  - ERROR_BATCH_NOT_FOUND (找不到指定的作業批次)
	//  - ERROR_US_MISMATCH (操作人員與機台登入人員不符)
	//  - ERROR_SR_SITE_NOT_FOUND (找不到指定操作工位)
	//  - ERROR_SW_MISMATCH (操作機台與派工單不符)
	//  - ERROR_RW_RESOURCE_MISSING (部份所需的材料未齊全)
	//  - ERROR_RESOURCE_NOT_FOUND (材料條碼不存在)
	//  - ERROR_RESOURCE_EXPIRED (材料過期)
	//  - ERROR_RESOURCE_ON_HOLD (材料狀態不能使用)
	//  - ERROR_RW_QUANTITY_BELOW_MIN (材料用量低於最低限制用量)
	//  - ERROR_RW_QUANTITY_ABOVE_MAX (材料用量高於最高限制用量)
	//  - ERROR_RW_QUANTITY_SHORTAGE (材料庫存不足))
	//  - ERROR_RW_BAD_GRADE (材料等級不符)
	//  - ERROR_RW_RESOURCE_UNEXPECTED (材料與配方不符)
	ResourceBind(context.Context, *api.ResourceBindRequest) (*api.ResourceBindReply, error)
	// 投料
	//
	// 投料功能須指定投料的工單(check.workOrder)
	//
	// 系統將依據 feeds 指定將從哪個材料工位(feeds.site) 或 投入指定某材料(feeds.resource)進行投料,
	// site.unique/index/resource 未來只會剩下index.
	// 投料必為依工位或投入指定材料條碼其中一個
	//
	// 材料檢查:
	//  - 檢查指定工位投入的材料是否可以使用,是否過期,庫存量等, 結果紀錄至 ResourceFeedReply.results.
	//
	// 生產紀錄:
	//  - 依據 feeds.quantity 數量進行生產紀錄, 如沒有給重量(feeds.quantity==null)則當作掛載的材料全部投入.
	//  - 一般執行(ACTION_AUTO)下重量給0時, 將不會紀錄生產資訊, 並回傳錯誤訊息.
	//  - 強制執行(ACTION_FORCE)下重量給0時, 強制投料, 並且紀錄數量為0的生產紀錄, 並回傳錯誤訊息.
	//
	// feeds.cumulative/byCollectInfo 功能未來將不支援.
	// closeBatch == true, 該次投料成功後, 該首數將不能再次投料(視為結束投料).
	// doNotStartBatch == true, 表示實際投料但並未開始生產, 系統會紀錄投料資訊但不變更首數狀態. (未來將棄用)
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - ERROR_RESOURCE_NOT_FOUND (材料條碼不存在)
	//  - ERROR_RESOURCE_EXPIRED (材料過期)
	//  - ERROR_RESOURCE_ON_HOLD (材料狀態不能使用)
	//  - ERROR_WORKORDER_NOT_FOUND (找不到指定的工單)
	//  - ERROR_WORKORDER_BAD_BATCH (該工單作業批次狀態無法進行掛載)
	//  - ERROR_BATCH_NOT_FOUND (找不到指定的作業批次)
	//  - ERROR_US_MISMATCH (操作人員與機台登入人員不符)
	//  - ERROR_SR_SITE_NOT_FOUND (找不到指定操作工位)
	//  - ERROR_SW_MISMATCH (操作機台與派工單不符)
	//  - ERROR_RW_QUANTITY_BELOW_MIN (材料用量低於配合表最低用量)
	//  - ERROR_RW_QUANTITY_ABOVE_MAX (材料用量高於配合表最高用量)
	//  - ERROR_RW_QUANTITY_SHORTAGE (材料庫存不足))
	//  - ERROR_RW_BAD_GRADE (材料等級不符)
	//  - ERROR_RW_RESOURCE_UNEXPECTED (材料與配方不符)
	//  - ERROR_RW_RESOURCE_MISSING (部份所需的材料未齊全)
	ResourceFeed(context.Context, *api.ResourceFeedRequest) (*api.ResourceFeedReply, error)
	// 收料
	//
	// 收料功能將會進行收料以及產出紀錄. 您必須指定 workOrder, collectBatch, quantity 告訴系統欲收料的工單號碼, 收料量
	// 相當於幾個首數(預設為1), 收料量.
	// 部份工程不提供工單要可以進行收料, 則需指定 product 資訊(id, type, unit)
	// ps: 不提供工單進行投收料的工程不得指定 Feed.AccordingRecipe.
	//
	// 您可透過 resource 指定這批產出的製品/成品紀錄至指定的標示卡條碼, 若無指定, 系統將自動產生一組標示卡條碼, 可從
	// CollectReply.resource 得知其標示卡號碼. 當您未指定標示卡條碼時, 您必須透過 carrier 指定其標示卡條碼應放置於哪一
	// 載具.
	// 部份工程沒有使用載具或是沒有規劃相關流程, 但有指定收料條碼(resource.ID), 則 carrier 可以不傳.
	//
	// 系統依據 actionMode 分成兩種執行模式: 一般執行(ACTION_AUTO)和強制執行(ACTION_FORCE), 預設為一般執行. 當處理請求
	// 時遇到系統認定為不正常操作(例如: 該首數狀態不可收料, 收料量大於投料量等)時, 會回饋錯誤到 CollectReply.error.
	// 您亦可透過強制執行(actionMode=ACTION_FORCE), 系統仍回饋錯誤並執行收料及產出紀錄, 依情況恐怕發生資料不齊全或無法
	// 預期狀況, 例如標示卡不存在的話, 將導致後段工程仍舊無法使用該條碼, 即使收料請求已被系統接受並執行.
	//
	// 若您想知道該批製品/成品更進一步資訊, 可透過 labelFields 指定需要知道的資訊, 目前支援:
	//  - product_type: 製品/成品類別, 例如: 天然橡膠, 合成橡膠, 鋼絲圈...等.
	//  - process_name: 製品生產流程代號
	//  - collect_quantity: 收取數
	//  - station: 機台號碼
	//  - manufacture_date: 製造日期時間
	//  - expiry: 製品/成品過期日期時間
	//  - operator: 收料人員
	//  - batch: 工單號碼+collectBatch
	//  - lot: 標示卡號碼
	//  - lot_number: 生產批號, 格式: 1碼工作群組+2碼機台編號+"-"+2碼月份+2碼日期, 例如: 工作群組=5, 機台編號=3,
	//                日期=2021-02-03, 其生產批號為: 503-0203.
	// 以上資訊可從 CollectReply.labelFields 獲得.
	//
	// 若您僅需要查詢收料紀錄, 可指定 onlyQueryLabels=true, 並給予以下資訊:
	//  - 工單編號(workOrder)
	//  - 收料序號(sequence)
	//  - 查詢欄位(labelFields)
	// 系統亦依據 metadata 的操作機台和當前登入人員, 篩選對應的收料紀錄(依據工單編號+生產批號+收料序號).
	// 若存在收料記錄, 依據 labelFields 回傳資料; 若不存在則回傳錯誤.
	//
	// 包含投料功能:
	//  - Feed.feeds 參考 resourceFeed 指定投入材料 or 從 site 投入指定材料
	//  - Feed.AccordingRecipe 決定是否依照配合表重量扣重, 不指定的話 feeds 投入材料必填重量
	//
	// 下列為回傳錯誤清單:
	//  - Error_ERROR_BAD_REQUEST
	//  - ERROR_RESOURCE_NOT_FOUND (材料條碼不存在)
	//  - ERROR_RESOURCE_EXISTED (收料標示卡已存在)
	//  - ERROR_WORKORDER_NOT_FOUND (找不到指定的工單)
	//  - ERROR_WORKORDER_BAD_BATCH (該工單作業批次狀態無法進行掛載)
	//  - ERROR_CARRIER_NOT_FOUND (找不到指定收取容器條碼)
	//  - ERROR_CARRIER_IN_USE (收料容器已被使用)
	//  - ERROR_BATCH_NOT_READY (該作業批次還不能收料)
	//  - ERROR_RW_QUANTITY_ABOVE_MAX (收取數量大於投料量, 超出允許收料範圍)
	//  - ERROR_WORKORDER_BAD_STATUS (工單狀態錯誤不允許進行操作)
	//  - ERROR_RECORD_EXISTED (收料紀錄已經存在)
	//  - ERROR_RECORD_NOT_FOUND (找不到收料紀錄)
	Collect(context.Context, *api.CollectRequest) (*api.CollectReply, error)
	// 寫入檢測數據
	RecordInspectResults(context.Context, *api.RecordInspectResultsRequest) (*api.RecordInspectResultsReply, error)
	// 查詢基準
	Recipe(context.Context, *api.RecipeRequest) (*api.RecipeReply, error)
	// 紀錄包裝秤重
	RecordPacking(context.Context, *api.RecordPackingRequest) (*api.RecordPackingReply, error)
	// 條碼查詢
	ListResources(context.Context, *api.ListResourcesRequest) (*api.ListResourcesReply, error)
	// 參數上傳
	UploadProductionParameters(API_UploadProductionParametersServer) error
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_WorkOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.WorkOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).WorkOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/WorkOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).WorkOrder(ctx, req.(*api.WorkOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Operator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.OperatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Operator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/Operator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Operator(ctx, req.(*api.OperatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ResourceBind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ResourceBindRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ResourceBind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/ResourceBind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ResourceBind(ctx, req.(*api.ResourceBindRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ResourceFeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ResourceFeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ResourceFeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/ResourceFeed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ResourceFeed(ctx, req.(*api.ResourceFeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Collect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.CollectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Collect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/Collect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Collect(ctx, req.(*api.CollectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RecordInspectResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.RecordInspectResultsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RecordInspectResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/RecordInspectResults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RecordInspectResults(ctx, req.(*api.RecordInspectResultsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Recipe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.RecipeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Recipe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/Recipe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Recipe(ctx, req.(*api.RecipeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RecordPacking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.RecordPackingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RecordPacking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/RecordPacking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RecordPacking(ctx, req.(*api.RecordPackingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.mes.v2.API/ListResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListResources(ctx, req.(*api.ListResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_UploadProductionParameters_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).UploadProductionParameters(&aPIUploadProductionParametersServer{stream})
}

type API_UploadProductionParametersServer interface {
	SendAndClose(*empty.Empty) error
	Recv() (*api.UploadProductionParametersRequest, error)
	grpc.ServerStream
}

type aPIUploadProductionParametersServer struct {
	grpc.ServerStream
}

func (x *aPIUploadProductionParametersServer) SendAndClose(m *empty.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPIUploadProductionParametersServer) Recv() (*api.UploadProductionParametersRequest, error) {
	m := new(api.UploadProductionParametersRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.mes.v2.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WorkOrder",
			Handler:    _API_WorkOrder_Handler,
		},
		{
			MethodName: "Operator",
			Handler:    _API_Operator_Handler,
		},
		{
			MethodName: "ResourceBind",
			Handler:    _API_ResourceBind_Handler,
		},
		{
			MethodName: "ResourceFeed",
			Handler:    _API_ResourceFeed_Handler,
		},
		{
			MethodName: "Collect",
			Handler:    _API_Collect_Handler,
		},
		{
			MethodName: "RecordInspectResults",
			Handler:    _API_RecordInspectResults_Handler,
		},
		{
			MethodName: "Recipe",
			Handler:    _API_Recipe_Handler,
		},
		{
			MethodName: "RecordPacking",
			Handler:    _API_RecordPacking_Handler,
		},
		{
			MethodName: "ListResources",
			Handler:    _API_ListResources_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadProductionParameters",
			Handler:       _API_UploadProductionParameters_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "services.proto",
}
