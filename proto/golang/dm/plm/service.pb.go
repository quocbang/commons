// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

package plm

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("service.proto", fileDescriptor_a0b84a42fa06f626) }

var fileDescriptor_a0b84a42fa06f626 = []byte{
	// 488 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x94, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x15, 0x90, 0x10, 0xb2, 0x0a, 0x15, 0xa6, 0xaa, 0x48, 0xfa, 0x27, 0xea, 0xb6, 0x55,
	0xa4, 0x48, 0x78, 0xa5, 0x72, 0x41, 0x39, 0xc2, 0x81, 0x4b, 0x2b, 0x55, 0x14, 0x2e, 0x5c, 0xa2,
	0x69, 0x3c, 0x18, 0x8b, 0x5d, 0xaf, 0x63, 0x8f, 0x4b, 0xb8, 0x72, 0xe1, 0x01, 0x7a, 0xe3, 0xb5,
	0x78, 0x05, 0x1e, 0x04, 0xed, 0x64, 0x9d, 0x7a, 0x53, 0xbb, 0xbd, 0xc0, 0xc9, 0x4a, 0xbe, 0xdf,
	0xce, 0x6f, 0xbe, 0x68, 0xe3, 0xe0, 0x49, 0x89, 0xc5, 0x55, 0x3a, 0xc3, 0x28, 0x2f, 0x0c, 0x99,
	0x70, 0x83, 0x1f, 0x51, 0xac, 0xa3, 0x5c, 0xe9, 0xc1, 0x6e, 0x62, 0x4c, 0xa2, 0x50, 0x42, 0x9e,
	0x4a, 0xc8, 0x32, 0x43, 0x40, 0xa9, 0xc9, 0xca, 0x25, 0x3b, 0x18, 0xf1, 0x43, 0xc6, 0x5a, 0xe6,
	0x4a, 0xcb, 0x2a, 0x8f, 0x81, 0x70, 0x9a, 0x2b, 0x0d, 0x44, 0xd3, 0x92, 0x80, 0xaa, 0x1a, 0x3c,
	0xf6, 0xc0, 0x04, 0xa9, 0xa6, 0x34, 0x2c, 0xa6, 0x25, 0xce, 0x1d, 0xb6, 0xef, 0x61, 0x2a, 0x2d,
	0x99, 0xd3, 0x50, 0x8f, 0x39, 0xec, 0xca, 0xa7, 0x54, 0x20, 0xde, 0x39, 0x04, 0x88, 0x5c, 0xde,
	0xf7, 0x72, 0x6f, 0xfe, 0xad, 0x68, 0x75, 0xea, 0xe4, 0xd7, 0xe3, 0xe0, 0xe1, 0xf9, 0xe9, 0x59,
	0xf8, 0x25, 0x08, 0x4e, 0xd3, 0x92, 0xce, 0xf9, 0x58, 0x38, 0x8c, 0x9a, 0xbf, 0x56, 0x74, 0x93,
	0xbc, 0xc7, 0x79, 0x85, 0x25, 0x0d, 0xf6, 0xba, 0x81, 0x5c, 0x7d, 0x17, 0x83, 0x1f, 0xbf, 0xff,
	0x5c, 0x3f, 0xd8, 0x12, 0x9b, 0xab, 0x5d, 0x97, 0xe9, 0xa4, 0x37, 0x0e, 0x17, 0xc1, 0xd3, 0x1b,
	0xfc, 0x43, 0x81, 0x18, 0x1e, 0x76, 0x0d, 0xb3, 0x69, 0x6d, 0x3c, 0xb8, 0x1b, 0xb2, 0xd6, 0x7d,
	0xb6, 0xbe, 0x10, 0xcf, 0xd7, 0xac, 0x96, 0xb0, 0xe6, 0x38, 0xd8, 0x78, 0x5b, 0x20, 0x10, 0xba,
	0x96, 0x3b, 0xfe, 0x48, 0xbf, 0x61, 0xbf, 0x3d, 0xb4, 0x9e, 0x5d, 0xf6, 0x6c, 0x8b, 0x67, 0xec,
	0x99, 0x35, 0x46, 0x3a, 0xcb, 0x47, 0xbe, 0x31, 0xff, 0xd4, 0x52, 0x35, 0x46, 0x5a, 0x4b, 0xda,
	0xe8, 0x02, 0x44, 0x2d, 0x16, 0x20, 0xea, 0xb6, 0x70, 0x68, 0x2d, 0x07, 0x6c, 0xd9, 0x11, 0xdb,
	0x6c, 0xf9, 0x9c, 0x2a, 0xac, 0x72, 0x65, 0x20, 0x76, 0xb5, 0x9c, 0x6a, 0x55, 0xe8, 0xbf, 0xa8,
	0x96, 0xdd, 0xac, 0x4a, 0xaf, 0x6e, 0xa1, 0x15, 0xb5, 0xdf, 0xc2, 0x86, 0x6c, 0xaf, 0x1b, 0xb0,
	0xc2, 0x21, 0x0b, 0xfb, 0x62, 0x6b, 0x5d, 0x68, 0xaf, 0x86, 0xd5, 0x5d, 0xf7, 0x82, 0xb0, 0x59,
	0xed, 0x82, 0xff, 0xdb, 0xe1, 0xc8, 0x1f, 0x7b, 0x9b, 0xa8, 0xfd, 0xc7, 0xf7, 0x83, 0x76, 0x8f,
	0x97, 0xbc, 0xc7, 0x48, 0x88, 0xf6, 0xe2, 0xcd, 0x03, 0x76, 0xab, 0x9f, 0xbd, 0x60, 0xf3, 0x1d,
	0xba, 0x26, 0x67, 0xb0, 0xb8, 0xc0, 0x79, 0x78, 0xe4, 0x9b, 0xd6, 0xe2, 0x7a, 0x1f, 0x71, 0x0f,
	0x65, 0x97, 0x19, 0xf3, 0x32, 0x47, 0x62, 0xb8, 0xbe, 0x4c, 0xe2, 0xd3, 0x93, 0xde, 0xf8, 0xcd,
	0xe4, 0xd3, 0xeb, 0x24, 0x25, 0x05, 0x97, 0xd1, 0x57, 0xcc, 0x62, 0x88, 0x66, 0x46, 0x47, 0xf4,
	0x4d, 0xf2, 0x07, 0x39, 0x33, 0x5a, 0x9b, 0xac, 0x94, 0x57, 0x27, 0x72, 0xf9, 0x7a, 0x49, 0x8c,
	0x82, 0x2c, 0x71, 0x6f, 0x99, 0xcb, 0x47, 0xfc, 0xe5, 0xab, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff,
	0xd4, 0x2b, 0x01, 0x82, 0x87, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PLMClient is the client API for PLM service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PLMClient interface {
	//取得PLM專案項次資料
	ListPlmmas(ctx context.Context, in *ListPlmmasRequest, opts ...grpc.CallOption) (*ListPlmmasReply, error)
	//取得PLM專案項次資料
	ListPlmmasTree(ctx context.Context, in *ListPlmmasTreeRequest, opts ...grpc.CallOption) (*ListPlmmasTreeReply, error)
	//新增PLM專案資料
	CreatePlmmas(ctx context.Context, in *PlmmasRequest, opts ...grpc.CallOption) (*PlmmasReply, error)
	//更新PLM專案資料
	UpdatePlmmas(ctx context.Context, in *PlmmasRequest, opts ...grpc.CallOption) (*PlmmasReply, error)
	//新增附件
	CreatePlmatt(ctx context.Context, in *PlmattRequest, opts ...grpc.CallOption) (*PlmattReply, error)
	//修改附件
	UpdatePlmatt(ctx context.Context, in *PlmattRequest, opts ...grpc.CallOption) (*PlmattReply, error)
	//查詢附件列表
	ListPlmatt(ctx context.Context, in *ListPlmattRequest, opts ...grpc.CallOption) (*ListPlmattReply, error)
	//更新附件狀態
	UpdatePlmattStatus(ctx context.Context, in *UpdatePlmattStatusRequest, opts ...grpc.CallOption) (*UpdatePlmattStatusReply, error)
	//取得最大SEQ
	GetPlmattMaxSeq(ctx context.Context, in *GetPlmattMaxSeqRequest, opts ...grpc.CallOption) (*GetPlmattMaxSeqReply, error)
}

type pLMClient struct {
	cc *grpc.ClientConn
}

func NewPLMClient(cc *grpc.ClientConn) PLMClient {
	return &pLMClient{cc}
}

func (c *pLMClient) ListPlmmas(ctx context.Context, in *ListPlmmasRequest, opts ...grpc.CallOption) (*ListPlmmasReply, error) {
	out := new(ListPlmmasReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/ListPlmmas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pLMClient) ListPlmmasTree(ctx context.Context, in *ListPlmmasTreeRequest, opts ...grpc.CallOption) (*ListPlmmasTreeReply, error) {
	out := new(ListPlmmasTreeReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/ListPlmmasTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pLMClient) CreatePlmmas(ctx context.Context, in *PlmmasRequest, opts ...grpc.CallOption) (*PlmmasReply, error) {
	out := new(PlmmasReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/CreatePlmmas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pLMClient) UpdatePlmmas(ctx context.Context, in *PlmmasRequest, opts ...grpc.CallOption) (*PlmmasReply, error) {
	out := new(PlmmasReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/UpdatePlmmas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pLMClient) CreatePlmatt(ctx context.Context, in *PlmattRequest, opts ...grpc.CallOption) (*PlmattReply, error) {
	out := new(PlmattReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/CreatePlmatt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pLMClient) UpdatePlmatt(ctx context.Context, in *PlmattRequest, opts ...grpc.CallOption) (*PlmattReply, error) {
	out := new(PlmattReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/UpdatePlmatt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pLMClient) ListPlmatt(ctx context.Context, in *ListPlmattRequest, opts ...grpc.CallOption) (*ListPlmattReply, error) {
	out := new(ListPlmattReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/ListPlmatt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pLMClient) UpdatePlmattStatus(ctx context.Context, in *UpdatePlmattStatusRequest, opts ...grpc.CallOption) (*UpdatePlmattStatusReply, error) {
	out := new(UpdatePlmattStatusReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/UpdatePlmattStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pLMClient) GetPlmattMaxSeq(ctx context.Context, in *GetPlmattMaxSeqRequest, opts ...grpc.CallOption) (*GetPlmattMaxSeqReply, error) {
	out := new(GetPlmattMaxSeqReply)
	err := c.cc.Invoke(ctx, "/proto.dm.plm.PLM/GetPlmattMaxSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PLMServer is the server API for PLM service.
type PLMServer interface {
	//取得PLM專案項次資料
	ListPlmmas(context.Context, *ListPlmmasRequest) (*ListPlmmasReply, error)
	//取得PLM專案項次資料
	ListPlmmasTree(context.Context, *ListPlmmasTreeRequest) (*ListPlmmasTreeReply, error)
	//新增PLM專案資料
	CreatePlmmas(context.Context, *PlmmasRequest) (*PlmmasReply, error)
	//更新PLM專案資料
	UpdatePlmmas(context.Context, *PlmmasRequest) (*PlmmasReply, error)
	//新增附件
	CreatePlmatt(context.Context, *PlmattRequest) (*PlmattReply, error)
	//修改附件
	UpdatePlmatt(context.Context, *PlmattRequest) (*PlmattReply, error)
	//查詢附件列表
	ListPlmatt(context.Context, *ListPlmattRequest) (*ListPlmattReply, error)
	//更新附件狀態
	UpdatePlmattStatus(context.Context, *UpdatePlmattStatusRequest) (*UpdatePlmattStatusReply, error)
	//取得最大SEQ
	GetPlmattMaxSeq(context.Context, *GetPlmattMaxSeqRequest) (*GetPlmattMaxSeqReply, error)
}

func RegisterPLMServer(s *grpc.Server, srv PLMServer) {
	s.RegisterService(&_PLM_serviceDesc, srv)
}

func _PLM_ListPlmmas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlmmasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).ListPlmmas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/ListPlmmas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).ListPlmmas(ctx, req.(*ListPlmmasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PLM_ListPlmmasTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlmmasTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).ListPlmmasTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/ListPlmmasTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).ListPlmmasTree(ctx, req.(*ListPlmmasTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PLM_CreatePlmmas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlmmasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).CreatePlmmas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/CreatePlmmas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).CreatePlmmas(ctx, req.(*PlmmasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PLM_UpdatePlmmas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlmmasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).UpdatePlmmas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/UpdatePlmmas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).UpdatePlmmas(ctx, req.(*PlmmasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PLM_CreatePlmatt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlmattRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).CreatePlmatt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/CreatePlmatt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).CreatePlmatt(ctx, req.(*PlmattRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PLM_UpdatePlmatt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlmattRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).UpdatePlmatt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/UpdatePlmatt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).UpdatePlmatt(ctx, req.(*PlmattRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PLM_ListPlmatt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlmattRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).ListPlmatt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/ListPlmatt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).ListPlmatt(ctx, req.(*ListPlmattRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PLM_UpdatePlmattStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePlmattStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).UpdatePlmattStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/UpdatePlmattStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).UpdatePlmattStatus(ctx, req.(*UpdatePlmattStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PLM_GetPlmattMaxSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlmattMaxSeqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PLMServer).GetPlmattMaxSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.dm.plm.PLM/GetPlmattMaxSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PLMServer).GetPlmattMaxSeq(ctx, req.(*GetPlmattMaxSeqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PLM_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.dm.plm.PLM",
	HandlerType: (*PLMServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPlmmas",
			Handler:    _PLM_ListPlmmas_Handler,
		},
		{
			MethodName: "ListPlmmasTree",
			Handler:    _PLM_ListPlmmasTree_Handler,
		},
		{
			MethodName: "CreatePlmmas",
			Handler:    _PLM_CreatePlmmas_Handler,
		},
		{
			MethodName: "UpdatePlmmas",
			Handler:    _PLM_UpdatePlmmas_Handler,
		},
		{
			MethodName: "CreatePlmatt",
			Handler:    _PLM_CreatePlmatt_Handler,
		},
		{
			MethodName: "UpdatePlmatt",
			Handler:    _PLM_UpdatePlmatt_Handler,
		},
		{
			MethodName: "ListPlmatt",
			Handler:    _PLM_ListPlmatt_Handler,
		},
		{
			MethodName: "UpdatePlmattStatus",
			Handler:    _PLM_UpdatePlmattStatus_Handler,
		},
		{
			MethodName: "GetPlmattMaxSeq",
			Handler:    _PLM_GetPlmattMaxSeq_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
